/*
 * main.cpp
 *
 *  Created on: 17 Apr 2020
 *      Author: Luqman_Hakim
 */

#include <Arduino.h>
#include <WiFi.h>
#include <Wire.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include "time.h"
#include "Adafruit_SHT31.h"
#include "Adafruit_GFX.h"
#include "Adafruit_SSD1306.h"
#include "Fonts/FreeMonoBold9pt7b.h"
#include "Fonts/FreeSerif9pt7b.h"
#include "serial_debug.h"

#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 64 // OLED display height, in pixels
#define OLED_RESET     -1 // Reset pin # (or -1 if sharing Arduino reset pin)

Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);
Adafruit_SHT31 sht31 = Adafruit_SHT31();

TaskHandle_t task_handle_sensing;
TaskHandle_t task_handle_clock;
SemaphoreHandle_t xMutex = xSemaphoreCreateMutex();

const char *ssid = "XLGO-C345";
const char *password = "240494ti";

const char *ntpServer = "pool.ntp.org";
const long gmtOffset_sec = 3600 * 7;
const int daylightOffset_sec = 0;

int split_line_x = display.width()*2/4 + 5;

// 'TI', 128x64px
const unsigned char trisna[] PROGMEM =
{
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe3, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xfc, 0x07, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8,
	0x1f, 0xc3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x7f, 0xe1, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xff, 0xf0, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe1, 0xff, 0xf8, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc3, 0xff, 0xfe, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xc3, 0xff, 0xfc, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xc3, 0xff, 0xf0, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x87, 0xff, 0xc0,
	0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x87, 0xff, 0x87, 0x03, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x87, 0xff, 0x0c, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x1c, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0x07, 0x00, 0x00, 0x73, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x08, 0x00,
	0x01, 0xf3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x03, 0x0f, 0xe3, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x1b, 0x8f, 0x83, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x33, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0x87, 0xf7, 0xc3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xcf, 0xe7, 0xf1, 0xfb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcf,
	0xcf, 0x80, 0x63, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0x0f, 0x00, 0x23,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc8, 0x00, 0x23, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0xc0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xf8, 0x78, 0x00, 0x0f, 0xff, 0x9f, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd,
	0xff, 0xff, 0xff, 0xff, 0x08, 0x7c, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x07,
	0xff, 0x03, 0xf8, 0x7f, 0xff, 0x8e, 0x04, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x03, 0xff, 0x83, 0xf8,
	0xe7, 0xff, 0x80, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x03, 0xff, 0xff, 0xf1, 0xc7, 0xff, 0x80,
	0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x03, 0xff, 0xff, 0x83, 0xcf, 0xff, 0xc0, 0x00, 0x3f, 0xff,
	0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x03, 0xff, 0xff, 0x8f, 0x8f, 0xff, 0xc0, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff,
	0xf8, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0x9f, 0xff, 0xc0, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00,
	0x01, 0xff, 0xff, 0xff, 0x1f, 0xff, 0xc0, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0xff, 0xff,
	0xfe, 0x3f, 0xff, 0xc0, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0xff, 0xff, 0xfe, 0x3f, 0xff,
	0xc0, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x0c, 0x7f, 0xff, 0xf8, 0xff, 0xff, 0xc0, 0x00, 0x3f,
	0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x7f, 0x7f, 0xfb, 0x1f, 0xff, 0xff, 0x80, 0x00, 0x3f, 0xff, 0xff, 0xff,
	0xff, 0xf8, 0x00, 0x00, 0x3f, 0x3f, 0xfe, 0x1f, 0xff, 0xff, 0x80, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00,
	0x00, 0x1f, 0xbf, 0xff, 0x7f, 0xff, 0xff, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x07, 0xbf,
	0xff, 0x7f, 0xff, 0xfe, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x03, 0xbf, 0xff, 0xff, 0xff,
	0xfc, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x07, 0x3f, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00,
	0x3f, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x07, 0x3f, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x3f, 0xff, 0xff,
	0xff, 0xff, 0xf8, 0x00, 0x00, 0x07, 0x3f, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xf8,
	0x00, 0x00, 0x07, 0x3f, 0xff, 0xff, 0xdf, 0xfc, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x07,
	0xff, 0xff, 0xff, 0xbf, 0xf8, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff,
	0xff, 0xf8, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xfe, 0xf8, 0x00,
	0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xfc, 0xf0, 0x00, 0x00, 0x3f, 0xff,
	0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xf8, 0xf0, 0x00, 0x00, 0x3f, 0xff, 0xff };

bool wifi_init()
{
	Serial.print("Connecting to ");
	Serial.println(ssid);
	WiFi.begin(ssid, password);
	if(WiFi.waitForConnectResult() != WL_CONNECTED)
	{
		Serial.printf("WiFi Failed!\n");
		return false;
	}
	Serial.println("");
	Serial.println("WiFi connected.");
	return true;
}

bool sht_init()
{
	return sht31.begin(0x44);
}

bool display_init()
{
	if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) return false;

	display.cp437(true);
	display.setTextSize(1);
	display.setTextColor(WHITE, BLACK);
	display.clearDisplay(); //clear adafruit opening

	// Display opening bitmap
	display.drawBitmap(0, 0, trisna, 128, 64, WHITE);
	display.display();

	delay(2000);
	display.clearDisplay();
	display.display();
	return true;
}

void display_write(const char *text, uint8_t text_size = 1)
{
	if(text_size != 1) display.setTextSize(text_size);
	display.println(text);
	if(text_size != 1) display.setTextSize(1);
}

void display_write(int pos_x, int pos_y, const char *text, uint8_t text_size = 1)
{
	display.setCursor(pos_x, pos_y);
	display_write(text, text_size);
}

void display_erase(int x, int y, int w, int h)
{
	display.fillRect(x, y, w, h, BLACK);
}

void display_time()
{
	char buff[256];
	struct tm timeinfo;
	int x_offset = split_line_x + 10;

	if(!getLocalTime(&timeinfo))
	{
		Serial.println("Failed to obtain time");
		return;
	}

	display_erase(split_line_x + 1, 0, display.width(), display.height());

	display.setFont(&FreeSerif9pt7b);

	strftime(buff, sizeof(buff), "%H:%M", &timeinfo);
	display_write(x_offset, 15, buff);

//	strftime(buff, sizeof(buff), "%M", &timeinfo);
//	display_write(split_line_x + 18, 30, buff);

	display.setFont(&FreeSerif9pt7b);
	strftime(buff, sizeof(buff) , "%a,", &timeinfo);
	display_write(x_offset, 35, buff);

	strftime(buff, sizeof(buff) , "%d/%m", &timeinfo);
	display_write(x_offset, 55, buff);

	display.setFont();
	display.display();

}

void display_sensing()
{
	char buff[256];

	float t = sht31.readTemperature();
	float h = sht31.readHumidity();
	t = round(t * 100)/100;
	h = round(h * 100)/100;

	if(!isnan(t))
	{  // check if 'is not a number'
		Serial.print("Temp *C = ");
		Serial.println(t);
	}
	else
	{
		Serial.println("Failed to read temperature");
		return;
	}

	if(!isnan(h))
	{  // check if 'is not a number'
		Serial.print("Hum. % = ");
		Serial.println(h);
	}
	else
	{
		Serial.println("Failed to read humidity");
		return;
	}

	display_erase(0, 0, split_line_x, display.height());

	display_write(0, 0, "temperature");
	sprintf(buff, "%.1fC",t);
	display_write(0, 10, buff,2);

	display_write(0, 35, "humidity");
	sprintf(buff, "%.1f%%",h);
	display_write(0, 45, buff,2);

	display.drawFastVLine(split_line_x, 0, display.height(), WHITE);
	display.display();
}

void task_sensing(void *parameter)
{
	while(1)
	{
		xSemaphoreTake(xMutex, portMAX_DELAY);
		display_sensing();
		xSemaphoreGive(xMutex);
		vTaskDelay(2000 / portTICK_RATE_MS);
	}
}

void task_clock(void *paramater)
{
	while(1)
	{
		xSemaphoreTake(xMutex, portMAX_DELAY);
		display_time();
		xSemaphoreGive(xMutex);
		vTaskDelay(1000 / portTICK_RATE_MS);

//		xSemaphoreTake(xMutex, portMAX_DELAY);
//		strftime(buff, sizeof buff, "%H:%M", &timeinfo);
//		display_time(buff);
//		xSemaphoreGive(xMutex);
//		vTaskDelay(5000 / portTICK_RATE_MS);
//
//		xSemaphoreTake(xMutex, portMAX_DELAY);
//		strftime(buff, sizeof buff, "%d %b %Y", &timeinfo);
//		display_time(buff);
//		xSemaphoreGive(xMutex);
//		vTaskDelay(5000 / portTICK_RATE_MS);
//
//		xSemaphoreTake(xMutex, portMAX_DELAY);
//		display.startscrollright(0x0A, 0x07);
//		xSemaphoreGive(xMutex);
//		vTaskDelay(5000 / portTICK_RATE_MS);

	}
}

void task_create_sensing()
{
	xTaskCreatePinnedToCore(task_sensing, /* Task function. */
							"task_sensing", /* name of task. */
							2000, /* Stack size of task */
							NULL, /* parameter of the task */
							2, /* priority of the task */
							&task_handle_sensing, /* Task handle to keep track of created task */
							1); /* pin task to core 1 */
	delay(100);
}

void task_create_clock()
{
	xTaskCreatePinnedToCore(task_clock, /* Task function. */
							"task_clock", /* name of task. */
							2000, /* Stack size of task */
							NULL, /* parameter of the task */
							1, /* priority of the task */
							&task_handle_clock, /* Task handle to keep track of created task */
							1); /* pin task to core 1 */
	delay(100);
}

void setup()
{
	Serial.begin(115200);
	if(display_init())
	{
		if(sht_init())
		{
			DEBUG_PRINTLN("sht init");
			display_write(0,0,"sht init ok");
			task_create_sensing();
		}
		else
		{
			display_write(0,0,"sht init ko");
		}
		display.display();

		if(wifi_init())
		{
			DEBUG_PRINTLN("wifi init");
			display_write(0,10,"wifi init ok");
			configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);
			display_write(0,20,"time init ok");
			task_create_clock();
		}
		else
		{
			display_write(0,10,"wifi init k0");
		}
		display.display();
	}
	vTaskResume(task_handle_sensing);
	vTaskResume(task_handle_clock);
}

void loop()
{

}
